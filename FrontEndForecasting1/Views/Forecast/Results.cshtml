@model List<MLINTERNSHIP.EnhancedForecastResult>
@{
	ViewData["Title"] = "Forecast Results";
	var fileName = ViewBag.FileName as string ?? "Unknown";
	var horizon = ViewBag.Horizon ?? 7;
	var horizonDisplay = ViewBag.HorizonDisplay as string ?? $"{horizon} days";
	var recordCount = ViewBag.RecordCount ?? 0;
	var forecastUnit = (ViewBag.ForecastUnit?.ToString()) ?? "Days";
	var forecastQuantity = ViewBag.ForecastQuantity ?? 7;
}

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>@ViewData["Title"] - Enhanced Dashboard</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link href="https://cdn.datatables.net/1.13.6/css/dataTables.bootstrap5.min.css" rel="stylesheet">
    <style>
        .chart-container {
            position: relative;
            height: 400px;
            margin-bottom: 30px;
        }

        .metric-card {
            transition: transform 0.2s;
            border-left: 4px solid #007bff;
        }

            .metric-card:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            }

        .performance-badge {
            font-size: 0.8rem;
        }

        .model-badge {
            font-weight: 600;
        }

        .table th {
            background-color: #212529 !important;
            color: #ffffff !important;
            border-bottom: 2px solid #dee2e6;
        }

        .forecast-value {
            font-weight: 600;
            color: #28a745;
            font-size: 1.1rem;
        }

        .confidence-interval {
            color: #6c757d;
            font-size: 0.9rem;
        }

        .prediction-highlight {
            background: linear-gradient(135deg, #e8f5e8 0%, #d4edda 100%);
            border-left: 4px solid #28a745;
            padding: 8px 12px;
            border-radius: 4px;
            margin: 4px 0;
        }

        .prediction-value {
            font-size: 1.2rem;
            font-weight: 700;
            color: #155724;
        }

        .prediction-unit {
            font-size: 0.9rem;
            color: #6c757d;
            margin-left: 4px;
        }

        .trend-indicator {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
            margin-left: 8px;
        }

        .trend-up {
            background-color: #d4edda;
            color: #155724;
        }

        .trend-down {
            background-color: #f8d7da;
            color: #721c24;
        }

        .trend-stable {
            background-color: #fff3cd;
            color: #856404;
        }

        .seasonal-pattern {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            border-left: 4px solid #2196f3;
            padding: 6px 10px;
            border-radius: 4px;
            margin: 2px 0;
            font-size: 0.9rem;
        }

        .loading-spinner {
            display: none;
        }

        .error-message {
            color: #dc3545;
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }

        .chart-legend {
            max-height: 200px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    @if (Model == null || !Model.Any())
    {
        <div class="container mt-5">
            <div class="alert alert-warning">
                <i class="fas fa-exclamation-triangle me-2"></i>
                No forecast results available. Please upload a valid CSV file with supply chain data.
            </div>
        </div>
    }
    else
    {
        <div class="container-fluid mt-4">
            <div class="d-flex justify-content-between align-items-center mb-4">
                <h2><i class="fas fa-chart-line text-success me-2"></i>Demand Forecast Dashboard</h2>
                <div>
                    <div class="btn-group me-2" role="group">
                        <button type="button" class="btn btn-outline-secondary dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">
                            <i class="fas fa-download me-1"></i>Export Results
                        </button>
                        <ul class="dropdown-menu">
                            <li><a class="dropdown-item" href="#" onclick="exportResults('csv')"><i class="fas fa-file-csv me-2"></i>Export as CSV</a></li>
                            <li><a class="dropdown-item" href="#" onclick="exportResults('excel')"><i class="fas fa-file-excel me-2"></i>Export as Excel</a></li>
                            <li><a class="dropdown-item" href="#" onclick="exportResults('json')"><i class="fas fa-file-code me-2"></i>Export as JSON</a></li>
                        </ul>
                    </div>
                    <a href="@Url.Action("NewUpload", "Forecast")" class="btn btn-primary">
                        <i class="fas fa-upload me-1"></i>Upload New File
                    </a>
                </div>
            </div>

            <!-- Summary Cards -->
            <div class="row mb-4">
                <div class="col-md-3">
                    <div class="card metric-card">
                        <div class="card-body">
                            <h5 class="card-title"><i class="fas fa-box text-primary me-2"></i>Products</h5>
                            <h3 class="text-primary" id="totalProducts"></h3>
                            <small class="text-muted">Forecasted items</small>
                        </div>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="card metric-card">
                        <div class="card-body">
                            <h5 class="card-title"><i class="fas fa-calendar text-info me-2"></i>Horizon</h5>
                            <h3 class="text-info" id="forecastHorizon"></h3>
                            <small class="text-muted">@horizonDisplay</small>
                        </div>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="card metric-card">
                        <div class="card-body">
                            <h5 class="card-title"><i class="fas fa-chart-bar text-warning me-2"></i>Avg SMAPE</h5>
                            <h3 class="text-warning" id="avgSmape"></h3>
                            <small class="text-muted">Model accuracy</small>
                        </div>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="card metric-card">
                        <div class="card-body">
                            <h5 class="card-title"><i class="fas fa-robot text-success me-2"></i>Best Model</h5>
                            <h3 class="text-success" id="bestModel"></h3>
                            <small class="text-muted">Most selected</small>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Prediction Summary Statistics -->
            <div class="row mb-4">
                <div class="col-12">
                    <div class="card">
                        <div class="card-header">
                            <h5 class="mb-0"><i class="fas fa-chart-pie text-primary me-2"></i>Prediction Summary Statistics</h5>
                        </div>
                        <div class="card-body">
                            <div class="row" id="predictionStats">
                                <!-- Statistics will be populated by JavaScript -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Charts Section -->
            <div class="row mb-4">
                <div class="col-lg-12">
                    <div class="card">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <h5 class="mb-0">Forecast Predictions by Product</h5>
                            <div>
                                <button class="btn btn-sm btn-outline-secondary" onclick="toggleChartType()">
                                    <i class="fas fa-exchange-alt me-1"></i>Switch View
                                </button>
                            </div>
                            <div>
                                <span class="text-muted">Product ID</span>
                                <input type="text" class="form-control form-control-sm" id="searchInput" placeholder="Search by Product ID" onkeyup="filterTable()">                                    
                            </div>
                        </div>
                        <div class="card-body">
                            <div class="chart-container">
                                <canvas id="forecastChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Summary Table -->
            <div class="card mb-4">
                <div class="card-header">
                    <h5 class="mb-0">Product Performance Summary</h5>
                </div>
                <div class="card-body">
                    <div class="table-responsive">
                        <table id="summaryTable" class="table table-striped table-bordered" style="width:100%">
                            <thead class="table-dark">
                                <tr>
                                    <th>Product ID</th>
                                    <th>Model</th>
                                    <th>Avg Forecast</th>
                                    <th>Forecast Range</th>
                                    <th>Performance</th>
                                    <th>Metrics</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody id="summaryTableBody">
                                <!-- Data will be populated by JavaScript -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <!-- Detailed Results -->
            <div class="card">
                <div class="card-header">
                    <h5 class="mb-0">Detailed Forecast Data</h5>
                </div>
                <div class="card-body">
                    <div class="table-responsive">
                        <table id="detailTable" class="table table-striped table-bordered" style="width:100%">
                            <thead class="table-dark">
                                <tr>
                                    <th>Product</th>
                                    <th>Day</th>
                                    <th>Forecast</th>
                                    <th>Confidence</th>
                                    <th>Model</th>
                                    <th>SMAPE</th>
                                    <th>MAPE</th>
                                    <th>R²</th>
                                </tr>
                            </thead>
                            <tbody id="detailTableBody">
                                <!-- Data will be populated by JavaScript -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- Product Detail Modal -->
        <div class="modal fade" id="productModal" tabindex="-1">
            <div class="modal-dialog modal-xl">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">Product Forecast Details - <span id="modalProductId"></span></h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                    </div>
                    <div class="modal-body">
                        <div class="row">
                            <div class="col-md-8">
                                <div class="chart-container">
                                    <canvas id="productChart"></canvas>
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="card">
                                    <div class="card-header">
                                        <h6 class="mb-0">Forecast Summary</h6>
                                    </div>
                                    <div class="card-body">
                                        <div id="productSummary">
                                            <!-- Summary data will be populated -->
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="row mt-3">
                            <div class="col-12">
                                <h6>Daily Forecast Breakdown</h6>
                                <div class="table-responsive">
                                    <table class="table table-sm">
                                        <thead>
                                            <tr>
                                                <th>Day</th>
                                                <th>Selected Model Forecast</th>
                                                <th>Confidence Interval</th>
                                                <th>Prophet</th>
                                                <th>XGBoost</th>
                                            </tr>
                                        </thead>
                                        <tbody id="modalTableBody">
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Scripts -->
        <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
        <script src="https://cdn.datatables.net/1.13.6/js/jquery.dataTables.min.js"></script>
        <script src="https://cdn.datatables.net/1.13.6/js/dataTables.bootstrap5.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>

        <script>
            var horizon = @horizon;
            var horizonDisplay = '@Html.Raw(horizonDisplay)';
            var forecastUnit = '@forecastUnit';
            var forecastQuantity = @forecastQuantity;
            var forecastData = [
            @foreach (var result in Model)
            {
                <text>
                            {
                                productId: "@result.ProductId",
                                selectedModel: "@result.SelectedModel",
                                predictions: @Html.Raw(Json.Serialize(result.Predictions)),
                                confidenceIntervals: @Html.Raw(Json.Serialize(result.ConfidenceIntervals)),
                                prophetPredictions: @Html.Raw(Json.Serialize(result.ProphetPredictions)),
                                xgBoostPredictions: @Html.Raw(Json.Serialize(result.XgBoostPredictions)),
                                prophetSMAPE: @result.ProphetSMAPE,
                                xgBoostSMAPE: @result.XgBoostSMAPE,
                                selectedModelSMAPE: @(result.SelectedModel == "Prophet" ? result.ProphetSMAPE : result.XgBoostSMAPE),
                                @if (result.AggregatedPredictions != null)
                                {
                                    <text>aggregatedPredictions: @Html.Raw(Json.Serialize(result.AggregatedPredictions)),</text>
                                }
                                else
                                {
                                    <text>aggregatedPredictions: null,</text>
                                }
                                @if (result.AggregatedConfidenceIntervals != null)
                                {
                                    <text>aggregatedConfidenceIntervals: @Html.Raw(Json.Serialize(result.AggregatedConfidenceIntervals)),</text>
                                }
                                else
                                {
                                    <text>aggregatedConfidenceIntervals: null,</text>
                                }
                                @if (result.AggregatedLabels != null)
                                {
                                    <text>aggregatedLabels: @Html.Raw(Json.Serialize(result.AggregatedLabels)),</text>
                                }
                                else
                                {
                                    <text>aggregatedLabels: null,</text>
                                }
                                request: {
                                    unit: '@(result.Request?.Unit.ToString() ?? "Days")',
                                    quantity: @(result.Request?.Quantity ?? 7),
                                    displayText: '@(result.Request?.GetDisplayText() ?? "7 days")'
                                },
                                @if (result.ForecastDates != null)
                                {
                                    <text>forecastDates: @Html.Raw(Json.Serialize(result.ForecastDates.Select(d => d.ToString("yyyy-MM-dd")))),</text>
                                }
                                else
                                {
                                    <text>forecastDates: [],</text>
                                }
                                metrics: {
                                    mape: @(result.Metrics?.MAPE ?? 0),
                                    rmse: @(result.Metrics?.RMSE ?? 0),
                                    mae: @(result.Metrics?.MAE ?? 0),
                                    r2: @(result.Metrics?.R2 ?? 0),
                                    smape: @(result.Metrics?.SMAPE ?? 0)
                                }
                            },
                </text>
            }
            ];

            let currentChart = null;
            let productChart = null;
            let chartType = 'line';

            $(document).ready(function() {
                console.log('Initializing dashboard with', forecastData.length, 'products');
                updateSummaryCards();
                populateTables();
                createCharts();
                initializeDataTables();
            });

            function updateSummaryCards() {
                const totalProducts = forecastData.length;

                if (totalProducts === 0) return;

                const avgSmape = (forecastData.reduce((sum, item) => sum + item.selectedModelSMAPE, 0) / totalProducts).toFixed(2);
                const modelCounts = {};
                forecastData.forEach(item => {
                    modelCounts[item.selectedModel] = (modelCounts[item.selectedModel] || 0) + 1;
                });
                const bestModel = Object.keys(modelCounts).reduce((a, b) => modelCounts[a] > modelCounts[b] ? a : b);

                document.getElementById('totalProducts').textContent = totalProducts;

                // Update forecast horizon display with proper unit information
                const forecastHorizonElement = document.getElementById('forecastHorizon');
                if (forecastData[0] && forecastData[0].request) {
                    const request = forecastData[0].request;
                    forecastHorizonElement.textContent = `${request.quantity} ${request.unit}`;

                    // Update the small text below
                    const forecastHorizonParent = forecastHorizonElement.closest('.card-body');
                    const smallText = forecastHorizonParent.querySelector('small');
                    if (smallText) {
                        smallText.textContent = request.displayText;
                    }
                } else {
                    forecastHorizonElement.textContent = horizon;
                }

                document.getElementById('avgSmape').textContent = avgSmape + '%';
                document.getElementById('bestModel').textContent = bestModel;
                
                // Update prediction statistics
                updatePredictionStatistics();
            }

            function updatePredictionStatistics() {
                if (forecastData.length === 0) return;

                const statsContainer = document.getElementById('predictionStats');
                if (!statsContainer) return;

                // Calculate comprehensive statistics
                const allPredictions = forecastData.flatMap(item => 
                    item.aggregatedPredictions && item.aggregatedPredictions.length > 0 && 
                    item.request && item.request.unit !== 'Days' ? 
                    item.aggregatedPredictions : item.predictions
                );

                const totalDemand = allPredictions.reduce((sum, val) => sum + val, 0);
                const avgDemand = totalDemand / allPredictions.length;
                const minDemand = Math.min(...allPredictions);
                const maxDemand = Math.max(...allPredictions);
                const demandRange = maxDemand - minDemand;

                // Calculate trend statistics
                const trends = forecastData.map(item => {
                    const predictions = item.aggregatedPredictions && item.aggregatedPredictions.length > 0 && 
                                     item.request && item.request.unit !== 'Days' ? 
                                     item.aggregatedPredictions : item.predictions;
                    
                    if (predictions.length < 2) return 0;
                    
                    const firstHalf = predictions.slice(0, Math.ceil(predictions.length / 2));
                    const secondHalf = predictions.slice(Math.ceil(predictions.length / 2));
                    
                    const firstAvg = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;
                    const secondAvg = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;
                    
                    return firstAvg > 0 ? ((secondAvg - firstAvg) / firstAvg) * 100 : 0;
                });

                const avgTrend = trends.reduce((sum, val) => sum + val, 0) / trends.length;
                const positiveTrends = trends.filter(t => t > 0).length;
                const negativeTrends = trends.filter(t => t < 0).length;

                // Create statistics cards
                const statsHTML = `
                    <div class="col-md-3">
                        <div class="card border-success">
                            <div class="card-body text-center">
                                <h6 class="card-title text-success">Total Forecasted Demand</h6>
                                <h3 class="text-success">${totalDemand.toFixed(0)}</h3>
                                <small class="text-muted">units across all products</small>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="card border-info">
                            <div class="card-body text-center">
                                <h6 class="card-title text-info">Average Demand</h6>
                                <h3 class="text-info">${avgDemand.toFixed(1)}</h3>
                                <small class="text-muted">units per period</small>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="card border-warning">
                            <div class="card-body text-center">
                                <h6 class="card-title text-warning">Demand Range</h6>
                                <h3 class="text-warning">${demandRange.toFixed(1)}</h3>
                                <small class="text-muted">min: ${minDemand.toFixed(1)}, max: ${maxDemand.toFixed(1)}</small>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="card border-primary">
                            <div class="card-body text-center">
                                <h6 class="card-title text-primary">Overall Trend</h6>
                                <h3 class="text-primary">${avgTrend > 0 ? '+' : ''}${avgTrend.toFixed(1)}%</h3>
                                <small class="text-muted">${positiveTrends} ↗, ${negativeTrends} ↘</small>
                            </div>
                        </div>
                    </div>
                `;

                statsContainer.innerHTML = statsHTML;
            }

            function populateTables() {
                populateSummaryTable();
                populateDetailTable();
            }

                    function populateSummaryTable() {
                const tbody = document.getElementById('summaryTableBody');
                if (!tbody) {
                    console.error('Summary table body not found');
                    return;
                }

                if (!forecastData || forecastData.length === 0) {
                    console.error('No forecast data available');
                    tbody.innerHTML = '<tr><td colspan="7">No data available</td></tr>';
                    return;
                }

                tbody.innerHTML = '';

                forecastData.forEach(item => {
                    // Use aggregated data for summary if available and not daily
                    const useAggregated = item.aggregatedPredictions &&
                                        item.aggregatedPredictions.length > 0 &&
                                        item.request &&
                                        item.request.unit !== 'Days';

                    const predictions = useAggregated ? item.aggregatedPredictions : item.predictions;
                    const avgForecast = (predictions.reduce((a, b) => a + b, 0) / predictions.length).toFixed(2);
                    const minForecast = Math.min(...predictions).toFixed(2);
                    const maxForecast = Math.max(...predictions).toFixed(2);
                    const range = `${minForecast} - ${maxForecast}`;
                    const smapeBadge = getPerformanceBadge(item.selectedModelSMAPE);

                    // Determine unit display
                    let unitDisplay = '7 days'; // default
                    if (item.request && item.request.displayText) {
                        unitDisplay = item.request.displayText;
                    }

                    const row = `
                        <tr>
                            <td><strong>${item.productId}</strong></td>
                            <td><span class="badge bg-primary model-badge">${item.selectedModel}</span></td>
                            <td>
                                <div class="prediction-highlight">
                                    <span class="prediction-value">${avgForecast}</span>
                                    <span class="prediction-unit">units</span>
                                    ${getTrendIndicator(predictions)}
                                </div>
                            </td>
                            <td>
                                <div class="seasonal-pattern">
                                    <strong>Range:</strong> ${range}<br>
                                    <small>Min: ${minForecast} | Max: ${maxForecast}</small>
                                </div>
                            </td>
                            <td>${smapeBadge}</td>
                            <td>
                                <div class="small">
                                    <strong>MAPE:</strong> ${item.metrics.mape.toFixed(2)}%<br>
                                    <strong>R²:</strong> ${item.metrics.r2.toFixed(3)}<br>
                                    <strong>Period:</strong> ${unitDisplay}
                                </div>
                            </td>
                            <td>
                                <button class="btn btn-sm btn-outline-primary" onclick="showProductDetails('${item.productId}')">
                                    <i class="fas fa-eye"></i> View
                                </button>
                            </td>
                        </tr>
                    `;
                    tbody.innerHTML += row;
                });
            }

        $('#summaryTableBody').DataTable({
            "pageLength": 10,
            "order": [[0, "asc"]],
            "scrollX": true,
            "responsive": true,
            "dom": 'Bfrtip',
            "language": {
                "search": "Search data:",
                "lengthMenu": "Show _MENU_ entries"
            }
        });

            function getTrendIndicator(predictions) {
                if (predictions.length < 2) return '';
                
                const firstHalf = predictions.slice(0, Math.ceil(predictions.length / 2));
                const secondHalf = predictions.slice(Math.ceil(predictions.length / 2));
                
                const firstAvg = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;
                const secondAvg = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;
                
                const change = ((secondAvg - firstAvg) / firstAvg) * 100;
                
                if (change > 5) {
                    return '<span class="trend-indicator trend-up">↗ +' + change.toFixed(1) + '%</span>';
                } else if (change < -5) {
                    return '<span class="trend-indicator trend-down">↘ ' + change.toFixed(1) + '%</span>';
                } else {
                    return '<span class="trend-indicator trend-stable">→ ' + change.toFixed(1) + '%</span>';
                }
            }

            function populateDetailTable() {
                const tbody = document.getElementById('detailTableBody');
                tbody.innerHTML = '';

                forecastData.forEach(item => {
                    // Use aggregated data if available and not daily
                    const useAggregated = item.aggregatedPredictions &&
                                        item.aggregatedPredictions.length > 0 &&
                                        item.request &&
                                        item.request.unit !== 'Days';

                    const predictions = useAggregated ? item.aggregatedPredictions : item.predictions;
                    const confidenceIntervals = useAggregated ? item.aggregatedConfidenceIntervals : item.confidenceIntervals;
                    const labels = useAggregated ? item.aggregatedLabels :
                                  Array.from({length: item.predictions.length}, (_, i) => `Day ${i + 1}`);

                    predictions.forEach((forecast, index) => {
                        const confidence = confidenceIntervals[index] || 0;
                        const label = labels[index] || `Period ${index + 1}`;

                        const row = `
                            <tr>
                                <td><strong>${item.productId}</strong></td>
                                <td>${label}</td>
                                <td>
                                    <div class="prediction-highlight">
                                        <span class="prediction-value">${forecast.toFixed(2)}</span>
                                        <span class="prediction-unit">units</span>
                                    </div>
                                </td>
                                <td class="confidence-interval">±${confidence.toFixed(2)}</td>
                                <td><span class="badge bg-secondary">${item.selectedModel}</span></td>
                                <td>${item.selectedModelSMAPE.toFixed(2)}%</td>
                                <td>${item.metrics.mape.toFixed(2)}%</td>
                                <td>${item.metrics.r2.toFixed(3)}</td>
                            </tr>
                        `;
                        tbody.innerHTML += row;
                    });
                });
            }

            function getPerformanceBadge(smape) {
                if (smape < 5) return `<span class="badge bg-success performance-badge">${smape.toFixed(2)}% Excellent</span>`;
                if (smape < 10) return `<span class="badge bg-warning text-dark performance-badge">${smape.toFixed(2)}% Good</span>`;
                if (smape < 20) return `<span class="badge bg-warning performance-badge">${smape.toFixed(2)}% Fair</span>`;
                return `<span class="badge bg-danger performance-badge">${smape.toFixed(2)}% Poor</span>`;
            }

            function updatePredictionStatistics() {
                if (forecastData.length === 0) return;

                const statsContainer = document.getElementById('predictionStats');
                if (!statsContainer) return;

                // Calculate comprehensive statistics
                const allPredictions = forecastData.flatMap(item => 
                    item.aggregatedPredictions && item.aggregatedPredictions.length > 0 && 
                    item.request && item.request.unit !== 'Days' ? 
                    item.aggregatedPredictions : item.predictions
                );

                const totalDemand = allPredictions.reduce((sum, val) => sum + val, 0);
                const avgDemand = totalDemand / allPredictions.length;
                const minDemand = Math.min(...allPredictions);
                const maxDemand = Math.max(...allPredictions);
                const demandRange = maxDemand - minDemand;

                // Calculate trend statistics
                const trends = forecastData.map(item => {
                    const predictions = item.aggregatedPredictions && item.aggregatedPredictions.length > 0 && 
                                     item.request && item.request.unit !== 'Days' ? 
                                     item.aggregatedPredictions : item.predictions;
                    
                    if (predictions.length < 2) return 0;
                    
                    const firstHalf = predictions.slice(0, Math.ceil(predictions.length / 2));
                    const secondHalf = predictions.slice(Math.ceil(predictions.length / 2));
                    
                    const firstAvg = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;
                    const secondAvg = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;
                    
                    return firstAvg > 0 ? ((secondAvg - firstAvg) / firstAvg) * 100 : 0;
                });

                const avgTrend = trends.reduce((sum, val) => sum + val, 0) / trends.length;
                const positiveTrends = trends.filter(t => t > 0).length;
                const negativeTrends = trends.filter(t => t < 0).length;

                // Create statistics cards
                const statsHTML = `
                    <div class="col-md-3">
                        <div class="card border-success">
                            <div class="card-body text-center">
                                <h6 class="card-title text-success">Total Forecasted Demand</h6>
                                <h3 class="text-success">${totalDemand.toFixed(0)}</h3>
                                <small class="text-muted">units across all products</small>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="card border-info">
                            <div class="card-body text-center">
                                <h6 class="card-title text-info">Average Demand</h6>
                                <h3 class="text-info">${avgDemand.toFixed(1)}</h3>
                                <small class="text-muted">units per period</small>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="card border-warning">
                            <div class="card-body text-center">
                                <h6 class="card-title text-warning">Demand Range</h6>
                                <h3 class="text-warning">${demandRange.toFixed(1)}</h3>
                                <small class="text-muted">min: ${minDemand.toFixed(1)}, max: ${maxDemand.toFixed(1)}</small>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="card border-primary">
                            <div class="card-body text-center">
                                <h6 class="card-title text-primary">Overall Trend</h6>
                                <h3 class="text-primary">${avgTrend > 0 ? '+' : ''}${avgTrend.toFixed(1)}%</h3>
                                <small class="text-muted">${positiveTrends} ↗, ${negativeTrends} ↘</small>
                            </div>
                        </div>
                    </div>
                `;

                statsContainer.innerHTML = statsHTML;
            }

            function createCharts() {
                createForecastChart();
            }

            function createForecastChart() {
                const ctx = document.getElementById('forecastChart').getContext('2d');
                if (currentChart) currentChart.destroy();

                // Enhanced color palette
                const colors = [
                    '#e74c3c', '#3498db', '#f39c12', '#2ecc71', '#9b59b6',
                    '#1abc9c', '#e67e22', '#34495e', '#f1c40f', '#e91e63'
                ];

                // Determine chart data and labels based on aggregation
                const datasets = forecastData.map((item, index) => {
                    // Use aggregated data if available and the forecast unit is not Days
                    const useAggregated = item.aggregatedPredictions &&
                                        item.aggregatedPredictions.length > 0 &&
                                        item.request &&
                                        item.request.unit !== 'Days';

                    const data = useAggregated ? item.aggregatedPredictions : item.predictions;
                    const chartLabels = useAggregated ? item.aggregatedLabels :
                                       Array.from({length: item.predictions.length}, (_, i) => `Day ${i + 1}`);

                    return {
                        label: `${item.productId} (${item.selectedModel})`,
                        data: data,
                        borderColor: colors[index % colors.length],
                        backgroundColor: colors[index % colors.length] + '30',
                        tension: 0.4,
                        fill: false,
                        borderWidth: 3,
                        pointBackgroundColor: colors[index % colors.length],
                        pointBorderColor: '#ffffff',
                        pointBorderWidth: 2,
                        pointRadius: 5
                    };
                });

                // Determine chart labels based on the first item's configuration
                let chartLabels = [];
                let xAxisTitle = 'Forecast Horizon';

                if (forecastData.length > 0) {
                    const firstItem = forecastData[0];
                    const useAggregated = firstItem.aggregatedPredictions &&
                                        firstItem.aggregatedPredictions.length > 0 &&
                                        firstItem.request &&
                                        firstItem.request.unit !== 'Days';

                    if (useAggregated) {
                        chartLabels = firstItem.aggregatedLabels || [];
                        
                        // Set appropriate x-axis title based on unit
                        switch (firstItem.request.unit) {
                            case 'Weeks':
                                xAxisTitle = `Weekly Forecast (${firstItem.request.quantity} weeks)`;
                                break;
                            case 'Months':
                                xAxisTitle = `Monthly Forecast (${firstItem.request.quantity} months)`;
                                break;
                            default:
                                xAxisTitle = `Forecast Horizon (${firstItem.request.displayText})`;
                        }
                    } else {
                        // For daily data or when no aggregation is available
                        chartLabels = Array.from({length: firstItem.predictions.length}, (_, i) => `Day ${i + 1}`);
                        xAxisTitle = `Daily Forecast (${firstItem.request ? firstItem.request.displayText : horizonDisplay})`;
                    }
                } else {
                    // Fallback labels
                    chartLabels = Array.from({length: horizon}, (_, i) => `Day ${i + 1}`);
                    xAxisTitle = `Forecast Horizon (${horizonDisplay})`;
                }

                // Determine chart title based on forecast unit
                let chartTitle = 'Demand Forecast';
                if (forecastData.length > 0 && forecastData[0].request) {
                    const unit = forecastData[0].request.unit;
                    const quantity = forecastData[0].request.quantity;
                    
                    switch (unit) {
                        case 'Days':
                            chartTitle = `Daily Demand Forecast - ${quantity} Day${quantity > 1 ? 's' : ''}`;
                            break;
                        case 'Weeks':
                            chartTitle = `Weekly Demand Forecast - ${quantity} Week${quantity > 1 ? 's' : ''}`;
                            break;
                        case 'Months':
                            chartTitle = `Monthly Demand Forecast - ${quantity} Month${quantity > 1 ? 's' : ''}`;
                            break;
                        default:
                            chartTitle = `Demand Forecast - ${horizonDisplay}`;
                    }
                }

                currentChart = new Chart(ctx, {
                    type: chartType,
                    data: {
                        labels: chartLabels,
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Forecast Value (Units)',
                                    font: {
                                        size: 12,
                                        weight: 'bold'
                                    }
                                },
                                grid: {
                                    color: 'rgba(0,0,0,0.1)'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: xAxisTitle,
                                    font: {
                                        size: 12,
                                        weight: 'bold'
                                    }
                                },
                                grid: {
                                    color: 'rgba(0,0,0,0.1)'
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 0
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                position: 'top',
                                labels: {
                                    usePointStyle: true,
                                    padding: 20
                                }
                            },
                            title: {
                                display: true,
                                text: chartTitle,
                                font: {
                                    size: 16,
                                    weight: 'bold'
                                },
                                padding: {
                                    top: 10,
                                    bottom: 30
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    title: function(context) {
                                        return context[0].label;
                                    },
                                    label: function(context) {
                                        const product = forecastData[context.datasetIndex];
                                        const value = context.parsed.y;
                                        const confidence = product.confidenceIntervals && 
                                                         product.confidenceIntervals[context.dataIndex] ? 
                                                         product.confidenceIntervals[context.dataIndex] : 0;
                                        
                                        let label = `${context.dataset.label}: ${value.toFixed(1)} units`;
                                        if (confidence > 0) {
                                            label += ` (±${confidence.toFixed(1)})`;
                                        }
                                        return label;
                                    },
                                    afterLabel: function(context) {
                                        const product = forecastData[context.datasetIndex];
                                        const dataIndex = context.dataIndex;
                                        
                                        // Get confidence interval
                                        let confidence = 0;
                                        if (product.aggregatedConfidenceIntervals && 
                                            product.aggregatedConfidenceIntervals.length > dataIndex &&
                                            product.request && product.request.unit !== 'Days') {
                                            confidence = product.aggregatedConfidenceIntervals[dataIndex];
                                        } else if (product.confidenceIntervals && 
                                                 product.confidenceIntervals.length > dataIndex) {
                                            confidence = product.confidenceIntervals[dataIndex];
                                        }
                                        
                                        let additionalInfo = '';
                                        if (confidence > 0) {
                                            additionalInfo += `Confidence: ±${confidence.toFixed(1)} units\n`;
                                        }
                                        
                                        // Add trend information
                                        if (product.predictions && product.predictions.length > 1) {
                                            const currentValue = product.predictions[dataIndex] || 0;
                                            const previousValue = dataIndex > 0 ? product.predictions[dataIndex - 1] : currentValue;
                                            const change = previousValue > 0 ? ((currentValue - previousValue) / previousValue) * 100 : 0;
                                            
                                            if (Math.abs(change) > 1) {
                                                const trend = change > 0 ? '↗' : '↘';
                                                additionalInfo += `Trend: ${trend} ${Math.abs(change).toFixed(1)}%\n`;
                                            }
                                        }
                                        
                                        return additionalInfo;
                                    }
                                },
                                backgroundColor: 'rgba(0,0,0,0.9)',
                                titleColor: 'white',
                                bodyColor: 'white',
                                borderColor: 'rgba(0,0,0,0.2)',
                                borderWidth: 2,
                                titleFont: {
                                    size: 14,
                                    weight: 'bold'
                                },
                                bodyFont: {
                                    size: 12
                                },
                                padding: 12,
                                cornerRadius: 8
                            }
                        },
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        }
                    }
                });
            }

            function initializeDataTables() {
                setTimeout(() => {
                    if ($.fn.DataTable) {
                        $('#summaryTable').DataTable({
                            pageLength: 10,
                            order: [[0, 'asc']],
                            responsive: true,
                            dom: 'Bfrtip',
                            language: {
                                search: "Search products:",
                                lengthMenu: "Show _MENU_ products"
                            }
                        });
                        $('#detailTable').DataTable({
                            pageLength: 25,
                            order: [[0, 'asc'], [1, 'asc']],
                            responsive: true,
                            language: {
                                search: "Search forecasts:",
                                lengthMenu: "Show _MENU_ entries"
                            }
                        });
                    }
                }, 500);
            }

            function toggleChartType() {
                chartType = chartType === 'line' ? 'bar' : 'line';
                createForecastChart();
            }

            function showProductDetails(productId) {
                const product = forecastData.find(item => item.productId === productId);
                if (!product) return;

                document.getElementById('modalProductId').textContent = productId;

                // Determine unit information
                let unitInfo = '7 days'; // default
                let unitType = 'Days';
                if (product.request) {
                    unitInfo = product.request.displayText || '7 days';
                    unitType = product.request.unit || 'Days';
                }

                // Enhanced summary with time unit information
                const summary = `
                    <div class="row">
                        <div class="col-6"><strong>Selected Model:</strong></div>
                        <div class="col-6">${product.selectedModel}</div>
                        <div class="col-6"><strong>Forecast Period:</strong></div>
                        <div class="col-6">${unitInfo}</div>
                        <div class="col-6"><strong>Forecast Type:</strong></div>
                        <div class="col-6">${unitType}</div>
                        <div class="col-6"><strong>Avg Forecast:</strong></div>
                        <div class="col-6">${(product.predictions.reduce((a,b) => a+b, 0) / product.predictions.length).toFixed(2)}</div>
                        <div class="col-6"><strong>Model SMAPE:</strong></div>
                        <div class="col-6">${product.selectedModelSMAPE.toFixed(2)}%</div>
                        <div class="col-6"><strong>Prophet SMAPE:</strong></div>
                        <div class="col-6">${product.prophetSMAPE.toFixed(2)}%</div>
                        <div class="col-6"><strong>XGBoost SMAPE:</strong></div>
                        <div class="col-6">${product.xgBoostSMAPE.toFixed(2)}%</div>
                        <div class="col-6"><strong>R²:</strong></div>
                        <div class="col-6">${product.metrics.r2.toFixed(3)}</div>
                    </div>
                `;
                document.getElementById('productSummary').innerHTML = summary;

                // Populate modal table with appropriate data based on time unit
                const modalTbody = document.getElementById('modalTableBody');
                modalTbody.innerHTML = '';

                // Determine whether to show daily breakdown or aggregated view
                const useAggregated = product.aggregatedPredictions &&
                                    product.aggregatedPredictions.length > 0 &&
                                    unitType !== 'Days';

                if (useAggregated) {
                    // Show aggregated breakdown (weekly/monthly)
                    product.aggregatedPredictions.forEach((forecast, index) => {
                        const label = product.aggregatedLabels[index] || `${unitType.slice(0, -1)} ${index + 1}`;
                        const confidence = product.aggregatedConfidenceIntervals[index] || 0;

                        // For aggregated view, we don't have daily Prophet/XGBoost breakdown
                        const row = `
                            <tr>
                                <td>${label}</td>
                                <td class="forecast-value">${forecast.toFixed(2)}</td>
                                <td class="confidence-interval">±${confidence.toFixed(2)}</td>
                                <td colspan="2"><em>Aggregated from daily predictions</em></td>
                            </tr>
                        `;
                        modalTbody.innerHTML += row;
                    });
                } else {
                    // Show daily breakdown
                    product.predictions.forEach((forecast, index) => {
                        const forecastDate = product.forecastDates && product.forecastDates[index] ?
                                            product.forecastDates[index] : '';
                        const row = `
                            <tr>
                                <td>Day ${index + 1}${forecastDate ? ` (${forecastDate})` : ''}</td>
                                <td class="forecast-value">${forecast.toFixed(2)}</td>
                                <td class="confidence-interval">±${product.confidenceIntervals[index].toFixed(2)}</td>
                                <td>${product.prophetPredictions[index].toFixed(2)}</td>
                                <td>${product.xgBoostPredictions[index].toFixed(2)}</td>
                            </tr>
                        `;
                        modalTbody.innerHTML += row;
                    });
                }

                // Create detailed chart for the product
                const ctx = document.getElementById('productChart').getContext('2d');
                if (productChart) productChart.destroy();

                // Determine chart configuration based on time unit
                let chartData, chartLabels, chartTitle, xAxisTitle;

                if (useAggregated) {
                    chartData = [{
                        label: `Selected (${product.selectedModel})`,
                        data: product.aggregatedPredictions,
                        borderColor: '#007bff',
                        backgroundColor: '#007bff20',
                        tension: 0.4,
                        borderWidth: 3
                    }];
                    chartLabels = product.aggregatedLabels;
                    chartTitle = `${productId} - ${unitInfo} ${unitType} Forecast`;
                    xAxisTitle = `${unitType} Periods`;
                } else {
                    chartData = [
                        {
                            label: `Selected (${product.selectedModel})`,
                            data: product.predictions,
                            borderColor: '#007bff',
                            backgroundColor: '#007bff20',
                            tension: 0.4,
                            borderWidth: 3
                        },
                        {
                            label: 'Prophet',
                            data: product.prophetPredictions,
                            borderColor: '#28a745',
                            backgroundColor: 'transparent',
                            borderDash: [5, 5],
                            tension: 0.4
                        },
                        {
                            label: 'XGBoost',
                            data: product.xgBoostPredictions,
                            borderColor: '#dc3545',
                            backgroundColor: 'transparent',
                            borderDash: [10, 5],
                            tension: 0.4
                        }
                    ];
                    chartLabels = Array.from({length: product.predictions.length}, (_, i) => `Day ${i + 1}`);
                    chartTitle = `${productId} - ${unitInfo} Daily Forecast Comparison`;
                    xAxisTitle = 'Daily Breakdown';
                }

                productChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: chartLabels,
                        datasets: chartData
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { position: 'top' },
                            title: {
                                display: true,
                                text: chartTitle,
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Forecast Value (Units)',
                                    font: { size: 11, weight: 'bold' }
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: xAxisTitle,
                                    font: { size: 11, weight: 'bold' }
                                }
                            }
                        },
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        }
                    }
                });

                const modal = new bootstrap.Modal(document.getElementById('productModal'));
                modal.show();
            }
            function exportResults(format = 'csv') {
                try {
                    // Create a form to submit the export request
                    const form = document.createElement('form');
                    form.method = 'POST';
                    form.action = '@Url.Action("Export", "Forecast")';
                    
                    // Add anti-forgery token
                    const token = document.querySelector('input[name="__RequestVerificationToken"]');
                    if (token) {
                        const tokenInput = document.createElement('input');
                        tokenInput.type = 'hidden';
                        tokenInput.name = '__RequestVerificationToken';
                        tokenInput.value = token.value;
                        form.appendChild(tokenInput);
                    }
                    
                    // Add format parameter
                    const formatInput = document.createElement('input');
                    formatInput.type = 'hidden';
                    formatInput.name = 'format';
                    formatInput.value = format;
                    form.appendChild(formatInput);
                    
                    // Add results data
                    const resultsInput = document.createElement('input');
                    resultsInput.type = 'hidden';
                    resultsInput.name = 'results';
                    resultsInput.value = JSON.stringify(forecastData);
                    form.appendChild(resultsInput);
                    
                    // Submit the form
                    document.body.appendChild(form);
                    form.submit();
                    document.body.removeChild(form);
                    
                    // Show success message
                    showNotification(`Exporting results as ${format.toUpperCase()}...`, 'info');
                } catch (error) {
                    console.error('Error exporting results:', error);
                    showNotification('Error exporting results. Please try again.', 'error');
                }
            }

            function showNotification(message, type = 'info') {
                // Create notification element
                const notification = document.createElement('div');
                notification.className = `alert alert-${type === 'error' ? 'danger' : type} alert-dismissible fade show position-fixed`;
                notification.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px;';
                notification.innerHTML = `
                    ${message}
                    <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
                `;
                
                // Add to page
                document.body.appendChild(notification);
                
                // Auto-remove after 5 seconds
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 5000);
            }
        </script>
    }
</body>
</html>